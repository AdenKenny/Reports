\documentclass[10pt, journal]{IEEEtran}

\usepackage[T1]{fontenc} % optional
\usepackage{cite}
\usepackage{url}
\usepackage{listings}
\usepackage[usenames]{xcolor}
\usepackage{fancyvrb}

\begin{document}
\title{Irene - A Netball Visualisation System}
\author{
\IEEEauthorblockN{Aden Kenny - 300334300}
}
\maketitle


\section{Introduction}
For the SWEN 422 course we were given a project to "design and implement a software system for an information visualisation application". This software system was required to allow "user to interactively explore a dataset containing the results of all matches in the first six seasons of the ANZ Championship.". Irene \cite{irene} is our implementation of the set specifications. Irene is a web application built with TypeScript, CSS, React.js, and D3.js. Irene was designed to be a personal assistant in the mould of Amazon's Alexa \cite{alexa} and Apple's Siri \cite{siri}. The major difference between our design of Irene and the former two, was that our "assistant" was not designed to be a general purpose assistant, or have any natural language processing ability. Irene was designed purely to display data from the ANZ Championship. Irene allows the user to ask a limited number of questions and shows the user graphs that help to answer their question. 


\section{Key design decisions and justification}

\subsection{Overall Design}
Our user interface was designed to be minimalistic, with a monochromatic colour palate of black and white. This colour palate was chosen as it complements the minimalistic design. The colour palate also has justification in colour theory. White is generally associated with "light, [and] goodness ... It usually has positive connotations and is seen as clean and safe" \cite{color}. The goodness aspect of white was considered to be important. Irene is meant to be a person who you're almost having a conversation with, and this is one of the main reasons why white plays such a large part in the chosen palate. Additionally, the clean aspect of white was important as we wanted our design to look clean, sleek, and minimalistic.  Black is seen as "formal and elegant" which we felt were important for our design, therefore black was used, mainly through the header, and as a standard font colour. The the black and white colour complement each other well by providing a clean look, but the two colours contrast well, letting us present a strong but clean design. A good example of this is looking at the header, where the background is black, providing a strong and solid background, then both the logo and title are a white that contrasts well with the black background. The colours represent their associations well, and the contrast of white on black helps to deliver our design goals to the user. 

We also considered whitespace to a key principle in our design. A good interface needs to have whitespace or it becomes difficult to navigate \cite{whitespace}, and therefore to use. The white space of our interface contrasts to the information and elements that are presented. This is especially important when we display our graphs, and other data, as we want to draw the users attention to them, and not have the users distracted by other elements.


\subsection{Prediction Bar}

One major design decision was the inclusion of the "prediction bar". This is the bar at the bottom of the screen that user can type their questions into and have them answered. When a user enters in a query they are taken to the relevant page where a graph is presented. All navigation of the system is through the prediction bar. This means that if a user does know how to or cannot use the prediction bar, they cannot use the system. In order to make sure that the user knows to use the prediction bar, we made sure that we had a strong visual hierarchy that directed the user towards it. The bar also has an autocomplete feature, but it has an extremely limited number of questions. The prediction bar is less of a search bar and more of a way of displaying questions. I feel that it is a fairly effective way of displaying questions and "railroading" a user towards what we want them to ask. The prediction bar is also designed make the user feel like they're having a conversation with Irene. We wanted the system to have a friendly feeling, rather than feel like a simple application where you click and a graph is shown, and I feel that the prediction bar helps the system to have a more human feel. 

The prediction bar also helps with the minimalistic style of the user interface, as it is always just one bar as opposed to many links or some kind of side or top menu.

It is open to debate if the prediction bar actually improves the user experience. I feel that if done well, and with enough time and resources, and in a large scale program, the prediction bar could prove to be a major selling point of the system. However, in this small, limited scale project it may have proved to not be a good design decision. This is primarily due to the large amount of development time it took to produce, and the fact that it feels slightly unpolished, primary due to the lack of questions. 

Overall I feel that the prediction bar was good design but it was perhaps not suited to this scale of project. It is extremely easy to add new questions to it but the development of it took a large portion of the project. This development time could have been better spent upskilling or creating more graphs to answer more questions. It would also be more suited for a larger scale project where more questions were required to be answered, and the development cycle was longer.

\subsection{Radar Chart}
We decided to use a radar chart to plot a teams overall performance. This means that it uses performance variables of teams (points, wins, losses, goals for, goals against, and goals for). The overall area of each team on the chart is meant to show the overall performance of a team i.e. a large area covered, the better the performance of the team. We considered the area correlating to a team's performance to be extremely important as humans are drawn towards the area of the a chart, and we felt that having the area not represent anything would be a waste of the strengths of the radar chart over a different type of graph. Correlating the area of the graph with the performance of a team did bring some downsides. A major reason for this is that a team is performing better when they have less goals against, but with the standard data in a radar chart, more goals against would mean a greater area covered, and therefore better performance.In order to make a low goals against value be bad for the performance of a team I decided to "invert" the goals against on the graph. To do this I went through all the goals against and found the highest (the lowest number), and added that number to all goals against. This meant that team with the worst goal difference would have zero goals against on our chart. I also scaled losses with the same technique.

After this, we still had the problem of some data points being significantly larger than others, such as wins and goals for. This meant that it was impossible to tell the difference between teams in terms of points and other statistics that had a lower mean value. In order to solve I decided that I would get a baseline value from the chart and scale values based upon that. This meant that all values fit nicely on the chart. The downside of this, along with the scaling of goals against and losses is that we have traded the area of the graph being significant for a lack of data values being accurately reflected in the graph. The only values that are not scaled in some way are the points and wins of each team, all other values are scaled but they are scaled so that the relationships between each teams variables are not impacted as every team is scaled by the same scale factors.

Overall I feel that the changes made in the data for the radar chart were worth it. It did mean that some data had to be scaled and inverted, but it preserved the meaning of the area of the chart. Without the area of the chart being meaningful, there was no real point of using a radar chart, therefore, in my opinion we made the right choice by choosing a radar chart, and scaling the data so it worked for the chart.

\subsection{Bar Chart}
We used a bar chart to display how teams do at certain venues, including alternative home venues. Each team has two bar charts, one for their home venues and one for their away venues. The charts plot win rate (\%) against venue, and each bar is split by the win rate, with a red area representing lost games and a green area representing wins. The colour choices were chosen as they are traditionally win and loss colours, and are widely known as representing wins and losses. The venues are ordered by number of games played at each venue. We felt this was important, especially when viewing away venues, as it is quite common that a team played only once at a certain venue. This means that the sample size of games is extremely small in some cases, and the graph probably becomes slightly less effective at conveying the information. However, I feel that the graph is quite effective when displaying the results of a team at their home venues. This is because while teams still play at multiple venues, the number is far smaller, therefore each venue has a larger sample size. This larger sample size for home venues means that the graph is far more effective at conveying information, as it actually makes sense to compare the venues when one result does not skew the graph, which can be contrasted against to away venues. 

Overall I feel that the choice of a bar chart can be justified in terms of display results at home venues, but not at away venues. When we decided to use a bar graph to show team performance across venues, we did not realise that the sample size would be so small for away venues. We considered changing the type of graph when we realised that the sample sizes for away venues were so small, but we thought it was important to have consistent visualisation method across both and home venues.

\section{Alternative design decisions} 

\subsection{Prediction Bar}
A number of alternatives were considered for the prediction bar. These were more traditional navigation techniques, that may have worked better on a small scale project like this. The first alternative could have been a side bar with links to the different kind of graphs. A side bar could have been a good choice as it immediately makes the options obvious to the user, and is fairly easy to navigate. The main difference between it and the chosen prediction bar, is the more "conversation like" feel the prediction bar brings to the system as well as the more personal touch.

An additional navigation option could have been a traditional web page with links to the various graphs and visualisation options. This could have also been a good choice as it is a traditional format that users are used to, and the prediction bar option may less familiar, at least in a non-search context (search contexts such as Google will be very familiar to users). A link orientated navigation system would also have the same downside as the side bar option, i.e. it would feel less "conversation like" and feel less personal. This conversationality and personal feel were considered to be important in our project so we decided to use the prediction bar style of navigation.

\subsection{Radar Chart}
A possible alternative to the radar chart could have been to give each team a bar chart for each performance statistic. This means that each team would have five graphs, each displaying one of points, wins, losses, goals for, goals against, and goal difference. How these could be arranged depends what the radar chart and bar chart are actually meant to show. The advantage of the radar chart is that it allows a user to view a team's overall performance and compare that performance against all the other teams in the competition, but a bar graph alternative wouldn't allow a user to compare all statistics, and therefore the overall performance of a team, of each team against each other. Therefore any alternative bar graph would need to choose to either focus on a team's overall performance on its own, or a single performance metric against other teams. I feel that the comparison to other teams is more important, so for an alternative to our radar chart, I would choose bar graphs comparing a single performance statistic plotted against the values from all teams. The main advantage of this method compared to the radar chart is that no scaling would need to be applied on the data, which would mean all the data displayed on the graph would accurately represent the data, which is a weakness of the radar chart.

Additionally a donut chart could be used to compare the performance of the all the teams against each other. One way this could be done is by combining the performance statistics of each team in some way, and then assigning a portion of the chart to each team based on their overall performance. This method would present some downsides, mainly that the statistics would be combined and this is one of the main downsides of the original radar chart. Another problem would be that with so many sections on the chart it could be difficult to pick each team out from the others.

Overall I feel that an alternative bar chart or donut chart would not have worked better than the radar chart we used. The radar chart did have some issues, but many of those were due to programming issues rather than inherent issues with the graph choice, and they would have been solved if more development type had been allocated. The only inherent issue is that the data needed to be scaled. In my opinion the power of being able to compare the overall performance of each team against all the others, outweighs the scaling issues. 

\subsection{Bar Chart}
I feel it would be hard to find a suitable alternative for the bar chart displaying a team's performance. One major reason for this is that I feel that the bar chart works well for home venue performance, but less well for away team performance. I feel that the main issue with away team performance is that it is extremely hard to compare performance by venue when many of the venues have a sample size of one or two. This downside is far less prevalent when comparing home team performance as the sample sizes become suitable large to be able to accurately draw conclusions. One partial solution to this issue could be to add a number on each bar showing the sample size of that bar. This would help a user to recognise when the sample size is small and that they should be cautious when drawing conclusions from the data displayed. This however would not solve the underlying issue, it would just be a partial fix. The main reason why I feel that the bar chart is a suitable graph for the question of team performance across venues is because it performs well when comparing home venues. The question that this answers asks the system to show "how teams do at certain venues, including how teams fare at different home venues that they alternate between.", and I feel that while there may be some issues with away performance, it works well for home performance which is a major part of the question. Additionally, I cannot think of any other graphs or charts that would not have larger downsides, especially once the above fix, to add a label showing the sample size, is applied to the current graph.

\section{Critique of development tools}
\subsection{D3.js}
As required for this project we used D3.js\cite{d3} to construct graphs. I found the usage of D3 to be rather difficult in some cases especially with our usage of React for building the other, non graph, UI elements. This is because both React and D3 want to control the DOM, and common usage patterns of D3 are "in direct conflict with React and its virtual DOM" \cite{meeks}. Examples and tutorials were also harder to find for using D3 with React as opposed to not using it. This made it more difficult to learn than it could have been otherwise. In the end, we found it much easier to use libraries that wrapped D3 charts that were designed to be used with a React program. These wrapped turned a D3 graph object (generally an svg) and turned them into a React component which made it extremely easy to use them with our program. The only issue with these wrappers is that it made it extremely easy to get a basic graph, it became hard to customise the graph, such as adding axis labels. This is because the libraries we used provided a React component (see the React section), which are far more difficult to customise than standard D3 code. This was in direct contrast to when we tried to use vanilla D3, it proved to be quite difficult to get a basic graph, but when we got a basic graph, it was easy to customise them with axis labels, different colours, and many other customisation options.

Another major issue we found was our combination of D3 and TypeScript. Significant amounts of online examples of D3 graphs would not work in our codebase. This was because they were coded to take full advantage of the "laxness" of JavaScript and its syntax. Examples of this included variables being declared without a variable declaration statement \cite{badcode} e.g.
\begin{verbatim}
dataValues = [];
\end{verbatim}

as opposed to -

\begin{Verbatim}[commandchars=\\\{\}]
\textcolor{blue}{let} dataValues = [];
\end{Verbatim}
~\\
TypeScript will not allow the first snippet of code as it will create a global variable (assuming \textit{dataValues} had not been previously declared), and is bad practice as it is important to keep the scope of variables as small as possible especially if they are mutable (as they are in this case). 

Our issues with poor quality of code in D3 examples and tutorials online did not result in TypeScript problems. We found significant amounts of examples that did not include semicolons. JavaScript without semicolons is technically syntactically correct code, and the JavaScript parser will insert semicolons where it thinks they should be, but this can result in unexpected and undesired behaviour. We found an example without semicolons that caused unexpected behaviour but when we attempted to fix it by inserting semicolons, we realised that the example relied on the compiler inserting semicolons in unexpected places.While this is not directly a fault with D3, but an issue with the ecosystem (JavaScript and some the of developers), it still impacted how we used and viewed D3. 

Another issue we faced with D3 was the lack of backwards compatibility. Major D3 updates (v3 to v4, or v4 to v5) seemed to remove old functions and features and replace them. This caused problems with older examples and tutorials that no longer worked. One solution would have been to downgrade to an older version, but some other examples that we found used some of the newer features that did not exist in the older versions. Additionally the newer versions fixed some bugs that were present in older versions. A lack of backwards compatibility is always hard to work with in a software context, and our experience was no exception to this rule.

Although D3 did present many problems throughout our project, once we had React wrappers for D3 graphs, it became much easier to implement our graphs. Overall I found that when working properly, D3 can be a powerful, and easy to use tool, but unfortunately there are some major downsides to it which can make it extremely frustrating and hard to use in some cases. 

\subsection{React}
We used React.js \cite{react} for building our user interface. I found React to be easy to use, and it made the sometimes difficult process of creating HTML and CSS interfaces much easier. React encourages the use of embedded HTML (in the form of JSX or TSX) to create components which can be reused as objects for creating a user interface. These components allow for easy reuse of code which means there is less code, and the code is generally "cleaner". A smaller amount of "cleaner" code is considered easier to reason about, which helps with preventing bugs. 

The component-object style of user interfaces felt far more natural to use when compared to the standard HTML, CSS, and JavaScript style. This was probably due to most of my previous experiences creating user interfaces being in an object oriented style (Swing, Qt, JavaFX, Android). 

React also proved to be easy to interoperate with TypeScript, which is slightly surprising given that TypeScript is maintained by Microsoft, and React by Facebook. The only major difference is that JSX (the HTML like syntax for building React components) can be put into .js files, but TSX (the TypeScript version of JSX) cannot be put into .ts files, it must be put in .tsx files.

\subsection{TypeScript}
We used TypeScript \cite{ts} in this project as a direct replacement for JavaScript. Since TypeScript is a strict superset of JavaScript, the TypeScript compiler complies our TypeScript code to plain JavaScript so, from a code behaviour perspective, there is no difference than if we were using JavaScript. I found TypeScript to be extremely useful in this project. The added static typing proved very useful when contrasted with JavaScript's dynamic, weak typing. TypeScript allows the usage of type signatures which makes reasoning about the code significantly easier in my experience. The usage of TypeScript also allowed us to catch a significant number of bugs much earlier than would have been possible if we were using JavaScript. This is primarily due to the fact that TypeScript is compiled to JavaScript therefore has a compilation step where some compile time bugs are caught. This is contrast to JavaScript, which is interpreted, and therefore bugs cannot be caught at compile time. The static nature of TypeScript also gave us autocompletion and far better refactoring support than if we were to use JavaScript. This was especially helpful as we are relatively new to web development and refactoring and autocomplete made our lives significantly easier while learning, especially when combined with a powerful IDE like Visual Studio Code \cite{vscode}.

Overall I found TypeScript to be pleasant to use in this project, especially in contrast to if we had to use JavaScript. The main reason for this is due to TypeScript's static typing. Using TypeScript made our program feel significantly less like "a house of cards" compared to previous experiences of programming in JavaScript. Unfortunately due to being a strict superset of JavaScript, TypeScript still has many of the warts of JavaScript such as the equality operator coercing the values. Overall, while I feel that TypeScript is a significantly more pleasant language to program in, and is easier to use than JavaScript, and it still has some major flaws, most of them are inherited from JavaScript.

\section{Conclusion}
Overall, I feel that all the key design decisions had solid justification when we started the project, but over the course of the project we found that some of them did not work out. Some of these ideas did not work or did not work as well as they could have, because of the implementation. This includes the radar chart, and the bar chart. Other ideas did not work out because they were flawed from the start, not because they were bad ideas, but because they did not suit the project. An example of this the prediction bar, which could be justified at the beginning of the project, but with hindsight did not suit this project. Alternatives to major design decisions were then proposed, and reasoning was given for the alternatives. Finally, a critique of development tools was carried out, with React and TypeScript  being singled out for praise.

\bibliographystyle{ieeetr}

\bibliography{bibliography}
\end{document}